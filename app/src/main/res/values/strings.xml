<resources>
    <string name="app_name">JavaDesignMode</string>
    <string name="stragegy_description">策略模式:\n&#160;&#160;实现同一个策略接口的的几个策略,各自实现其策略方法,
        并用一个类管理这几个策略, 程序将要使用这几种策略时,只需要调用这个管理类固定的方法, 并传入某个策略就可以了</string>
    <string name="proxy_description"> 代理模式: \n 实现同一个接口的两个类A,B, B中持有A的引用,
        B的实现方法中实际上是调用A对象的对应方法,这时B就是A的代理,如果C要实现A的功能, 只要调用B就可以了(并将A传入B) </string>
    <string name="single_mode">单例模式:\n 只能实例化一个对象,可以用私有构造方法(懒汉式和饿汉式)和静态内部类的方法实现单例</string>
    <string name="factory_mode">&#160;&#160;创建对象的任务交给工厂类,而不是自己创建,可以用map管理已经创建过的对象.
        \n  &#160;&#160;工厂模式:\n &#160;&#160;产品抽象, 给工厂类传入一个产品类型的Class/或者一个能体现类型的参数 , 返回这种类型的对象
        \n  &#160;&#160;工厂方法模式:\n &#160;&#160;工厂抽象,产品抽象,有几种产品就有几种工厂,新增加产品时,只要新增加工厂就能满足需求
        \n  &#160;&#160;抽象工厂模式:\n &#160;&#160;工厂抽象,产品抽象,有多个抽象产品,当每个抽象产品都有多个具体的子类时候,
        抽象工厂模式提供多个具体的工厂角色,每个工厂负责一种产品的实例化
    </string>
    <string name="facede_mode">门面模式: \n 对事情执行的内容和顺序封装 ,比如发送消息, 封装了消息内容,目的地址, 和发送过程, 用户只需要提供必要的信息就可以\n
    理解方式：去餐厅吃饭，只需要跟服务员交互就可以了， 点单， 做饭，结账的事情交给服务员帮忙。 门面负责处理所有的事情，使用者只需要跟门面交互 </string>
    <string name="adapter_mode"> 适配器模式 ：把一种模式的数据类型转换成所需要的模型(继承共同的借口)</string>

    <string name="observer_mode"> 观察者模式 ： 被观察者持有观察者的引用，在有事件发生时候，被观察着调用观察者执行既定的动作，
        这个动作的执行也称为观察者观察到事件发生后作出的动作。如果观察者比较多，且处理时间较长，选择异步处理，
        异步处理要考虑线程安全和队列的问题。（待解决，参考 Message Queue）</string>
    <string name="template_mode"> 模板方法模式：通过汇总或排序基本方法而产生的结果集，提供一个抽象类，如果扩展功能，就继承这个类，
        然后修改重写的抽象方法，最后调用最终执行的方法。通过固定的模式，扩展功能 </string>
    <string name="builder_mode"> 建造者模式 ：\n
        定义： 将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示，\n
        适用条件：需要产生的对象有复杂的内部结构，对象属性相互依赖，对象的创建过程中会使用一些不易得到的对象，\n
        功能： 基本方法的调用顺序安排,重心在于分离构建算法和具体的构建实现
        重要部分: builder 定义了如何构建部件  director : 定义了如何组合来构建产品,
    </string>
    <string name="bridge_mode">
        <Data>
            桥梁模式 <![CDATA[<br>]]>
            <![CDATA[<font color="#ff6400" >业务抽象角色&#160;</font>引用<font  color="#ff6400">业务实现角色</font><br>]]>
             可解决继承的缺点问题,将抽象化与实现化脱耦，使得二者可以独立地变化。<![CDATA[<br>]]>
            (1)由<![CDATA[<font color="#f05050">抽象化角色</font>]]>和<![CDATA[<font color="#f05050"> 修正抽象化角色</font>]]> 组成的抽象化等级结构。<![CDATA[<br>]]>
            (2)由<![CDATA[<font color="#f05050">实现化角色</font>]]>和<![CDATA[<font color="#f05050"> 两个具体实现化角色</font>]]>所组成的实现化等级结构。<![CDATA[<br>]]>
            特点: 抽象化和实现化之间使用聚合关系而不是继承关系, 从而使两者可以相对独立地变化
        </Data>

    </string>
    <string name="command_mode">命令模式 -> 三个角色:
        \n Receiver 收到命令后干活的
        \n Command 发放命令的
        \n Invoker 接头人, 接收命令并下发
        \n 把请求命令和执行过程分别封装并分开, 有很好的扩展性 , 但如果命令非常多的话, 会导致类爆炸

    </string>
    <string name="decorator_mode">装饰模式: 定义一个类(A),要装饰的类(B),A继承B , 将B传入A中,在A中对B进行装饰 </string>


    <string name="iterator_mode">迭代器模式:提供一种方法顺序访问聚合对象中的各种元素. 而又不暴露对象内部表示\n
        主要有两种角色,具体产品角色和迭代器角色 , 产品角色将自己内部的对象内容输入到迭代器角色中, 然后被迭代器角色遍历输出\n
        逐渐没落的设计模式, 因为一般高级语言都有Iterator的接口或实现, 直接使用List或Map即可完成任务
    </string>
    <string name="composite_mode">组合模式 ->几个角色:  \n
        抽象构建角色:定义参加组合的共同特征(默认的行为,属性)\n
        树枝构建:组合树枝节点和叶子节点\n
        叶子构建:下面没有分支\n
        在树枝结构中适合使用组合模式\n
        组合模式分为:安全模式和透明模式
    </string>
    <string name="chain_mode"> 责任链模式： \n
            屏蔽了请求的处理过程,作为请求者可以不用知道到底是需要谁来处理的，这是责任链模式的核心\n
            A能处理就处理， 处理不了丢给B , B来处理， B不能处理就丢给C来处理, 一次类推 ， 类似android事件分发机制.\n
            缺点：调试不便，特别是链条长,环节多的时候，由于采用了类似递归的方式，调试的时候逻辑可能比较复杂。\n
            角色: 不同类型的待处理事件 event , 不同类型的handler (处理事件)
    </string>
    <string name="visitor_mode"> 访问模式： \n
        基本套路: 具体元素实现 accept 方法，通常是 visitor.visit(this)\n
        是对迭代器模式的扩充, 可以访问不同对象,执行不同操作\n
        其他使用: 统计功能 ,多访问者 ,拦截器功能\n
        具体元素负责数据加载, 访问者负责数据展示, 单一职责原则
    </string>
    <string name="state_mode"> 状态模式： \n
        定义： 当一个对象内在状态改变时，允许其改变行为 ，这个对象看起来是改变了其类\n
            每一种状态定义一个类，状态转换的逻辑判断在具体状态类中实现\n
        情形： 适用于某个对象转状态改变时，行为发生较大变化的情况\n
        优点： 避免程序的（结构）复杂性，减少了状态条件的判断,状态的变换放置在类中实现\n
        缺点： 如果状态过多，会造成类膨胀
    </string>
    <string name="prototype_mode"> 原型模式： \n
        不通过new关键字来产生一个对象，而是通过对象拷贝来实现的模式
        （对象拷贝时， 类的构造方法不会被执行)\n
        情形：对象初始化需要消化资源较多或new需要大量数据准备和权限申请，
        浅拷贝和深拷贝：\n
        浅拷贝： java Object提供的clone ， 只会拷贝对象本身， 不会拷贝对象内部的数组和引用对象，
            拷贝出来的对象和被拷贝对象 内部对象引用指向相同的内存地址，内部数组也一样\n
        深拷贝： 对对象内部的对象和数组再单独拷贝\n
        被final修饰的变量不可被拷贝\n

    </string>
    <string name="mediator_mode"><![CDATA[<strong>中介模式：</strong>]]> <![CDATA[<br>]]>
        <![CDATA[几个有<font color="#f05050"><strong>相互关联</strong></font>的类中间添加一个中介者，各个类除了中介者不与其他类联系，降低了类之间的耦合性]]><![CDATA[<br>]]>
        <![CDATA[<strong>关键角色:</strong>]]> 抽象中介者角色 ， 具体中介者角色，同事角色<![CDATA[<br>]]>
        <![CDATA[<strong>缺点：</strong>]]> 如果colleague类比较多，且逻辑复杂的话，虽然结构清晰了，但中介类会很庞大很复杂， 让维护更加困难<![CDATA[<br>]]>
        典型的MVC结构就用了中介模式， controller充当中介者的角色，处理View和数据之间的关系。<![CDATA[<br>]]>
    </string>
    <string name="interpreter_mode"> 解释器模式：\n
        按照规定语法进行解释的模式, 文法+解释器\n
        文法：规定语句的组合形式， \n
        解释器：用来解释指定文法结构的语句\n
        例子：perl语言的语法 + 解释器 -> 代码执行
    </string>
    <string name="flyweight_mode">享元模式：\n
        对象共享,把已经创建的对象放置在集合中保存，下次使用时候直接在集合中取出，如果集合中没有这个对象，
        就创建并保存在集合中
    </string>
    <string name="memento_mode">备忘录模式：\n
        在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
        这样以后就可将该对象恢复到原先保存的状态\n
        Origintor:负责创建一个备忘录，记住当前时刻自身状态，\n
        Memento:存储Origintor内部状态，并可以防止其他对象访问备忘录\n
        careTaker：负责管理备忘录，不能访问备忘录\n

    </string>
</resources>