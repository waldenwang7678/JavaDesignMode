<resources>
    <string name="app_name">JavaDesignMode</string>
    <string name="stragegy_description">策略模式:\n&#160;&#160;实现同一个策略接口的的几个策略,各自实现其策略方法,
        并用一个类管理这几个策略, 程序将要使用这几种策略时,只需要调用这个管理类固定的方法, 并传入某个策略就可以了</string>
    <string name="proxy_description"> 代理模式: \n 实现同一个接口的两个类A,B, B中持有A的引用,
        B的实现方法中实际上是调用A对象的对应方法,这时B就是A的代理,如果C要实现A的功能, 只要调用B就可以了(并将A传入B) </string>
    <string name="single_mode">单例模式:\n 只能实例化一个对象,可以用私有构造方法(懒汉式和饿汉式)和静态内部类的方法实现单例</string>
    <string name="factory_mode">&#160;&#160;创建对象的任务交给工厂类,而不是自己创建,可以用map管理已经创建过的对象.
        \n  &#160;&#160;工厂模式:\n &#160;&#160;产品抽象, 给工厂类传入一个产品类型的Class/或者一个能体现类型的参数 , 返回这种类型的对象
        \n  &#160;&#160;工厂方法模式:\n &#160;&#160;工厂抽象,产品抽象,有几种产品就有几种工厂,新增加产品时,只要新增加工厂就能满足需求
        \n  &#160;&#160;抽象工厂模式:\n &#160;&#160;工厂抽象,产品抽象,有多个抽象产品,当每个抽象产品都有多个具体的子类时候,
        抽象工厂模式提供多个具体的工厂角色,每个工厂负责一种产品的实例化
    </string>
    <string name="facede_mode">门面模式: \n 对事情执行的内容和顺序封装 ,比如发送消息, 封装了消息内容,目的地址, 和发送过程, 用户只需要提供必要的信息就可以\n
    理解方式：去餐厅吃饭，只需要跟服务员交互就可以了， 点单， 做饭，结账的事情交给服务员帮忙。 门面负责处理所有的事情，使用者只需要跟门面交互 </string>
    <string name="adapter_mode"> 适配器模式 ：把一种模式的数据类型转换成所需要的模型(继承共同的借口)</string>

    <string name="observer_mode"> 观察者模式 ： 被观察者持有观察者的引用，在有事件发生时候，被观察着调用观察者执行既定的动作，
        这个动作的执行也称为观察者观察到事件发生后作出的动作。如果观察者比较多，且处理时间较长，选择异步处理，
        异步处理要考虑线程安全和队列的问题。（待解决，参考 Message Queue）</string>
    <string name="template_mode"> 模板方法模式：通过汇总或排序基本方法而产生的结果集，提供一个抽象类，如果扩展功能，就继承这个类，
        然后修改重写的抽象方法，最后调用最终执行的方法。通过固定的模式，扩展功能 </string>
    <string name="builder_mode"> 建造者模式 ：\n
        定义： 将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示，\n
        适用条件：需要产生的对象有复杂的内部结构，对象属性相互依赖，对象的创建过程中会使用一些不易得到的对象，\n
        功能： 基本方法的调用顺序安排,重心在于分离构建算法和具体的构建实现
        重要部分: builder 定义了如何构建部件  director : 定义了如何组合来构建产品,
    </string>
    <string name="bridge_mode">
        <Data>
            桥梁模式 <![CDATA[<br>]]>
            <![CDATA[<font color="#ff6400" >业务抽象角色&#160;</font>引用<font  color="#ff6400">业务实现角色</font><br>]]>
             可解决继承的缺点问题,将抽象化与实现化脱耦，使得二者可以独立地变化。<![CDATA[<br>]]>
            (1)由<![CDATA[<font color="#f05050">抽象化角色</font>]]>和<![CDATA[<font color="#f05050"> 修正抽象化角色</font>]]> 组成的抽象化等级结构。<![CDATA[<br>]]>
            (2)由<![CDATA[<font color="#f05050">实现化角色</font>]]>和<![CDATA[<font color="#f05050"> 两个具体实现化角色</font>]]>所组成的实现化等级结构。<![CDATA[<br>]]>
            特点: 抽象化和实现化之间使用聚合关系而不是继承关系, 从而使两者可以相对独立地变化
        </Data>

    </string>
    <string name="command_mode">命令模式 -> 三个角色:
        \n Receiver 收到命令后干活的
        \n Command 发放命令的
        \n Invoker 接头人, 接收命令并下发
        \n 把请求命令和执行过程分别封装并分开, 有很好的扩展性 , 但如果命令非常多的话, 会导致类爆炸

    </string>
    <string name="decorator_mode"> </string>
</resources>