<resources>
    <string name="app_name">JavaDesignMode</string>
    <string name="stragegy_description">策略模式:\n&#160;&#160;实现同一个策略接口的的几个策略,各自实现其策略方法,
        并用一个类管理这几个策略, 程序将要使用这几种策略时,只需要调用这个管理类固定的方法, 并传入某个策略就可以了</string>
    <string name="proxy_description"> 代理模式: \n 实现同一个接口的两个类A,B, B中持有A的引用,
        B的实现方法中实际上是调用A对象的对应方法,这时B就是A的代理,如果C要实现A的功能, 只要调用B就可以了(并将A传入B) </string>
    <string name="single_mode">单例模式:\n 只能实例化一个对象,可以用私有构造方法(懒汉式和饿汉式)和静态内部类的方法实现单例</string>
    <string name="factory_mode">&#160;&#160;创建对象的任务交给工厂类,而不是自己创建,可以用map管理已经创建过的对象.
        \n  &#160;&#160;工厂模式:\n &#160;&#160;产品抽象, 给工厂类传入一个产品类型的Class/或者一个能体现类型的参数 , 返回这种类型的对象
        \n  &#160;&#160;工厂方法模式:\n &#160;&#160;工厂抽象,产品抽象,有几种产品就有几种工厂,新增加产品时,只要新增加工厂就能满足需求
        \n  &#160;&#160;抽象工厂模式:\n &#160;&#160;工厂抽象,产品抽象,有多个抽象产品,当每个抽象产品都有多个具体的子类时候,抽象工厂模式提供多个具体的工厂角色,每个工厂负责一种产品的实例化
    </string>
    <string name="facede_mode">门面模式: \n 对事情执行的内容和顺序封装 ,比如发送消息, 封装了消息内容,目的地址, 和发送过程, 用户只需要提供必要的信息就可以\n
    理解方式：去餐厅吃饭，只需要跟服务员交互就可以了， 点单， 做饭，结账的事情交给服务员帮忙。 门面负责处理所有的事情，使用者只需要跟门面交互 </string>
    <string name="adapter_mode"> 适配器模式 ：把一种模式的数据类型转换成所需要的模型(继承共同的借口)</string>

    <string name="observer_mode"> 观察者模式 ： 被观察者持有观察者的引用，在有事件发生时候，被观察着调用观察者执行既定的动作，
        这个动作的执行也称为观察者观察到事件发生后作出的动作。如果观察者比较多，且处理时间较长，选择异步处理，
        异步处理要考虑线程安全和队列的问题。（待解决，参考 Message Queue）</string>
    <string name="template_mode"> 模板方法模式：通过汇总或排序基本方法而产生的结果集，提供一个抽象类，如果扩展功能，就继承这个类，
        然后修改重写的抽象方法，最后调用最终执行的方法。通过固定的模式，扩展功能 </string>
    <string name="builder_mode"> 建造者模式：需要产生的对象有复杂的内部结构，对象属性相互依赖，对象的创建过程中会使用一些不易得到的对象，
    这种情况下比较适合使用建造者模式</string>
</resources>
