<resources>
    <string name="app_name">JavaDesignMode</string>
    <string name="stragegy_description">策略模式:\n&#160;&#160;实现同一个策略接口的的几个策略,各自实现其策略方法,
        并用一个类管理这几个策略, 程序将要使用这几种策略时,只需要调用这个管理类固定的方法, 并传入某个策略就可以了</string>
    <string name="proxy_description"> 代理模式: \n 实现同一个接口的两个类A,B, B中持有A的引用,
        B的实现方法中实际上是调用A对象的对应方法,这时B就是A的代理,如果C要实现A的功能, 只要调用B就可以了(并将A传入B) </string>
    <string name="single_mode">单例模式:\n 只能实例化一个对象,可以用私有构造方法(懒汉式和饿汉式)和静态内部类的方法实现单例</string>
    <string name="factory_mode">&#160;&#160;创建对象的任务交给工厂类,而不是自己创建,可以用map管理已经创建过的对象.
        \n  &#160;&#160;工厂模式:\n &#160;&#160;产品抽象, 给工厂类传入一个产品类型的Class/或者一个能体现类型的参数 , 返回这种类型的对象
        \n  &#160;&#160;工厂方法模式:\n &#160;&#160;工厂抽象,产品抽象,有几种产品就有几种工厂,新增加产品时,只要新增加工厂就能满足需求
        \n  &#160;&#160;抽象工厂模式:\n &#160;&#160;工厂抽象,产品抽象,有多个抽象产品,当每个抽象产品都有多个具体的子类时候,抽象工厂模式提供多个具体的工厂角色,每个工厂负责一种产品的实例化
    </string>
    <string name="facede_mode">门面模式: \n 对事情执行的内容和顺序封装 ,比如发送消息, 封装了消息内容,目的地址, 和发送过程, 用户只需要提供必要的信息就可以\n
    理解方式：去餐厅吃饭，只需要跟服务员交互就可以了， 点单， 做饭，结账的事情交给服务员帮忙。 门面负责处理所有的事情，使用者只需要跟门面交互 </string>
    <string name="adapter_mode"> 适配器模式 ：把一种模式的数据类型转换成所需要的模型(继承共同的借口)</string>
</resources>
